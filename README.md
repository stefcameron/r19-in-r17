[![CI](https://github.com/stefcameron/r19-in-r17/actions/workflows/ci.yml/badge.svg?branch=master)](https://github.com/stefcameron/r19-in-r17/actions/workflows/ci.yml) [![license](https://badgen.now.sh/badge/license/MIT)](./LICENSE)

# r19-in-r17

A prototype monorepo to explore the challenges of async-loading a React 19-based component (`<Dialog />`), provided from a library package ([react-19](./packages/react-19/)) built with Rollup, into a React 17-based [app](./packages/react-17/) built with Webpack.

## Observations

The key thing to note, after trying to do this with the `createPortal()` react-dom API, is that one version of React is unable (i.e. will refuse) to render a JSX object generated by some other version (I assume major version, though untested) of React.

Even by moving the `createPortal()` call into the `react-19` package bundle (which bundles react@19 and react-dom@19, ensuring that the `createPortal()` called is the react-dom@19 version, not the react-dom@17 one), since `createPortal()` still returns JSX to render, react@17 will refuse it, resulting in the following error:

```text
react-dom.development.js:13231 Uncaught Error: Objects are not valid
as a React child (found: object with keys {$$typeof, type, key, props,
_owner, _store}). If you meant to render a collection of children,
use an array instead.
```

The only way to do this is to render the react@19-based component using an entirely separate React root using react-dom@19's `createRoot()` API from the `react-19` package bundle.

In this prototype, the `react-19` package is a bundle that contains react@19, react-dom@19, and exports a `renderDialogRoot()` function that creates a new root when called.

The `react-17` app then dynamically loads the `react-19` package at runtime and calls the `renderDialogRoot()` when an "Open Dialog" button (from react@17) is clicked.

> ðŸŸ£ Note that it isn't possible to render the `react-19` Dialog _inside_ the `react-17` app's root. Therefore, this technique is best reserved for things like popovers or modals that are naturally expected to "float" above the app by design.

Another use would be for micro frontends (MFE) where each MFE is rendered in its own root, although it would be ideal with all MFEs used the same version of React/DOM to keep the app's memory footprint smaller. If that's the case, then Webpack 5's [ModuleFederationPlugin](https://webpack.js.org/plugins/module-federation-plugin/) could be a big bonus, enabling each MFE to share a single version of react and react-dom libraries already loaded in the window.

## Installation

Use the latest `node` and `pnpm` executables, and run `pnpm install` from the repo root.

## Running

1. Run `pnpm build` to build all the packages in dependency order.
2. Run the `react-17` app.

Running `pnpm start` from the repo root will do all of the above and open a browser to the __react-17__ app running on port `3000`.

The `react-19` app can be run on its own by running `pnpm start:19` from the repo root. A browser will open to the app running on port `3001`.

## Scripts

```bash
# installs all dependencies
$ pnpm install
# builds all packages and opens a browser to localhost:3000
# set PORT=XXXX in env to run on a different port
$ pnpm start

# formats the code using Prettier
$ pnpm run fmt
# builds the production bundle
$ pnpm run build
```

> ðŸ’¬ If your browser doesn't open, please open it manually to `localhost:3000`

## Testing

```bash
# checks formatting, linting, build, and tests
$ pnpm run test
# runs unit tests only
$ pnpm run test:unit
# full format check (style, lint, typings)
$ pnpm run lint
# runs Prettier in verification mode only
$ pnpm run fmt:check
# formats the code and then checks for lint errors
$ pnpm run verify
```
